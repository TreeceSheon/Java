线程池参数：核心线程数、总线程数、延迟时长、单位、阻塞队列以及拒绝策略。

线程池的execute逻辑分三种情况：
① 如果当前的核心线程数小于阈值，则继续直接创建一个线程，用于执行当前任务。 
一旦核心线程开启总数达到阈值后，所有的新提交任务都会被放进阻塞队列里，由Worker从队列里提取
② 如果当前核心线程全部开启，则检查当前线程池状态并将任务放入阻塞队列。放入后二次检查线程池状态，如果依旧为正常状态则结束execute方法，反则将任务从队列中移除，原因是在execute方法完成之前，线程池已经被shutdown了。此时执行拒绝策略。此时如果已经不在running状态了，但又没有成功将任务从阻塞队列中移除if(!isRunning(recheck)&&remove(command)) == false，同时也没有活着的worker去管理当前队列中的任务，则新建一个新的worker(null,false)去获取队列中的方法并执行。
③如果阻塞队列已满但当前未达到总线程数上限，则临时申请新的线程执行task，否则申请失败执行拒绝策略。

在线程池执行execute方法时，关键的辅助方法addWorker()执行逻辑：
采用CAS机制新建工作线程，期间检查线程池的状态。如果线程池状态被修改为shutdown，则添加失败；如果CAS失败，则重试。
在addWorker()方法中，创建完Worker对象后，会直接调用线程的start()方法开启线程；而之后都只会从阻塞队列中获取。

什么时候Worker的数量会减少？
Worker只在第一次调用的时候被创建，期间一般不会被销毁，除非超出了核心线程数量，addWorker操作失败或者是在shutdownb被调用，以及线程池设置了核心线程超时的情况下。

线程池如何实现线程的重用？
①阻塞：在不设定核心线程超时的情况下，阻塞是默认的重用实现，当线程无法从阻塞队列中拿去新的任务去执行时，当前的worker会被阻塞在获取任务那里，直到有新的任务被提交。
②定时：在设定了核心线程超时的情况下，重用的实现是定时，即poll(timeout, TIMEUNIT)方法。核心线程会尝试60秒的阻塞，一旦时间到了以后还没有获取到新的任务，则run()方法结束，核心线程数自减1。

getTask()方法的内部逻辑是什么？
